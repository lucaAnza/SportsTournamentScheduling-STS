\documentclass{article}

% Core math + hyperlinks (does not change fonts/margins)
\usepackage{amsmath, amssymb}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{todonotes}

% ---- Metadata (edit) ----
\title{CMDO 2025 - Sports Tournament Scheduling
(STS) problem}
\author{%
Luca Anzaldi \texttt{luca.anzaldi@studio.unibo.it} \and
Martino Michelotti \texttt{martino.michelotti@studio.unibo.it}
}
\date{\today}

% ---- Helpful macros (optional) ----
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\opt}{\mathrm{opt}}
\newcommand{\AllDiff}{\texttt{allDifferent}}

\begin{document}
\maketitle

\todo{Delete prof introduction}
\section{Introduction}
This report addresses the solution of the well-known \emph{Sports Tournament Scheduling Problem (STS)}.
The focus is on presenting different modeling approaches and optimization techniques to handle the scheduling constraints and objectives.  
Throughout the report we describe the common elements that underlie all models: the inputs, symbols, shared objective variable and bounds, global pre-processing, and any assumptions. 
To avoid repetition, later sections will refer back to this introduction whenever these shared components are required.

\paragraph{Instance parameters}
Let \(T\) be the number of teams (even), \(W=T-1\) the number of weeks, and \(P=T/2\) the number of periods (parallel timeslots) per week.
Each solution is modeled referring to these three main variables.

\begin{itemize}
    \item Example1 : $ T = 6 \xrightarrow{} W = 4 $ and  $ P = 3 $
    \item Example2 : $ T = 16 \xrightarrow{} W = 15 $ and  $ P = 8 $
    \item Example3 : $ T = 5  \xrightarrow{} $ NOT VALID 
\end{itemize}

\paragraph{General constraints}
The classical formulation of the STS problem requires that:
\begin{enumerate}
    \item every team plays with every other team exactly once;
    \item every team plays exactly once per week;
    \item every team plays at most twice in the same period over the whole tournament.
\end{enumerate}

\paragraph{Objective function}

The main optimization criterion is to achieve a balanced schedule,
in which every team plays approximately the same number of home and away
games. In particular, given the instance parameters 
$T$ teams, $W$ weeks, and $P$ periods.
The objective is to minimize the overall imbalance:

\[
\min \; \sum_{t=1}^{T} \Big| \; 
\#\text{home\_games}(t) - \#\text{away\_games}(t) \; \Big|
\]

This formulation depends only on the instance parameters
($T, W, P$) that define how many games each team must play,
and expresses the high-level goal of fairness in the tournament.




% ---------------- CP ----------------
\clearpage
\section{CP Model}
This section is mandatory.

\subsection{Decision variables}
List all CP variables, with domains and semantics.
For example: $B_i \in \{0,\dots,100\}$ meaning $B_i = j$ iff baker $i$ cooks $j$ cakes.

\subsection{Objective function}
If the objective variable/bounds differ from Section~1, state it here.
Then give the CP objective. Example: minimize total area
$ \sum_{i=1}^{n} W_i \cdot H_i $.

\subsection{Constraints}
State and explain main problem constraints first; then (optionally) implied and symmetry-breaking constraints.

\paragraph{Main constraints.}
Formalize each constraint compactly and explain its role.

\paragraph{Implied constraints (optional).}
Explain why implied constraints hold and how they tighten propagation.

\paragraph{Symmetry breaking (optional).}
Identify model symmetries and show how your constraints reduce them.

\subsection{Validation}
Implement the model in \texttt{MiniZinc}; run at least \texttt{Gecode}
(and optionally other solvers). Design reproducible experiments.

\paragraph{Experimental design.}
Specify solvers, search strategies, hardware/software, time limits, and any per-instance settings.

\paragraph{Experimental results.}
Report objective values (best found or proven optimal).
Mark proven optima in \textbf{bold}. Use \texttt{UNSAT} if proven infeasible; use \texttt{N/A} or ``--'' on timeout.

\begin{table}[h]
\centering
\caption{Results with/without symmetry breaking (example layout).}
\label{tab:cp}
\begin{tabular}{lcccc}
\toprule
\textbf{ID} & \textbf{Chuffed+SB} & \textbf{Chuffed--SB} & \textbf{Gecode+SB} & \textbf{Gecode--SB}\\
\midrule
1 & \textbf{80} & 120 & 80 & 80 \\
2 & 50 & 60 & N/A & N/A \\
3 & UNSAT & UNSAT & N/A & N/A \\
\bottomrule
\end{tabular}
\end{table}

% ---------------- SAT ----------------
\clearpage
\section{SAT Model}

The SAT solution was made using two different modeling approaches. Both are included in the report. 

\paragraph{Notation.}
Throughout the constraints we use the following shorthand:

\[
\begin{aligned}
\sum x_i \;\;\geq k &\quad\Longleftrightarrow\quad \text{``at least $k$ of the $x_i$ are true''}, \\[6pt]
\sum x_i \;\;= k   &\quad\Longleftrightarrow\quad \text{``exactly $k$ of the $x_i$ are true''}, \\[6pt]
\sum x_i \;\;\leq k &\quad\Longleftrightarrow\quad \text{``at most $k$ of the $x_i$ are true''}.
\end{aligned}
\]

In the implementation these correspond respectively to the encodings 
\texttt{at\_least\_k}, \texttt{exactly\_k}, and \texttt{at\_most\_k}. The special cases with $k=1$ are captured by the usual constraints:
$ \texttt{at\_least\_one}, 
\texttt{at\_most\_one}, $ and $ 
\texttt{exactly\_one}.
$

\vspace{1em}
\textit{Model~1} was implemented using several alternative SAT encodings for the cardinality
constraints introduced above. In particular, we considered the \textbf{Bitwise} encoding,
the \textbf{Heule} encoding, the \textbf{Pairwise} encoding, and the \textbf{Sequential} encoding.
Each encoding provides a different trade-off between the number of variables,
the number of clauses, and the strength of constraint propagation.

\vspace{1em}
\textit{Model~2} extends the formulation of Model~1 by adding further constraints and auxiliary decision variables. In contrast to Model~1, the implementation adopts a single SAT encoding approach (e.g., pairwise-style cardinality constraints) and does not perform a systematic comparison across alternative encodings.

Moreover, the implementation can optionally enable a \textbf{precomputing} phase: a round-robin pairing generator fixes in advance which team pairs are allowed to play in each week, and the corresponding ($M_{t_1,t_2,w}$) variables are forced to either true or false accordingly. This reduces the search space by eliminating week–pair symmetries and infeasible match placements before solving, allowing us to study how much of the performance change comes from a more constrained model versus additional upfront structural pruning.

The purpose of Model~2 is therefore not to benchmark competing encoding techniques, but to assess how a more expressive formulation.



\subsection{Decision variables}

\subsubsection{Model - 1}

The use of multiple encodings within the same model allows for a systematic
comparison of their impact on solver performance, while keeping the underlying
problem formulation fixed.

\paragraph{Booleans}

\begin{itemize}
    \item  $ X_{t,h,p,w}\in\{0,1\} \quad\text{meaning team }t\text{ is scheduled with role }h\text{ in slot }(p,w). $
\end{itemize}

\subsubsection{Model - 2}

\paragraph{Booleans}

\begin{itemize}
    \item  $ M_{t_1,t_2,w} \in \{0,1\} \quad\text{meaning teams $t_1$ and $t_2$ play against each other in week $w$}. $
    \item $HOME_{t,w} \in \{0,1\} \quad\text{meaning team $t$ plays at home in week $w$ (away otherwise)}.$
    \item $P_{t,p,w} \in \{0,1\} \quad\text{meaning team $t$ is assigned to period $p$ in week $w$}.$
\end{itemize}


\paragraph{Remarks.}

Model--2 introduces explicit pair variables \(M_{t_1,t_2,w}\) to capture
which two teams meet in a given week, home assignment variables
\(HOME_{t,w}\) to distinguish roles, and period variables
\(P_{t,p,w}\) to ensure consistency of scheduling. It also supports
a \emph{precomputing} mode, where a round-robin structure is generated
in advance and infeasible pairs are pruned by setting the corresponding
\(M_{t_1,t_2,w}\) literals to false.


\subsection{Objective function}

\subsubsection{Model - 1}

We minimize total home/away imbalance across teams:
\[
\min \;\; \sum_{t=1}^{T} \left| 
\sum_{p=1}^{P}\sum_{w=1}^{W} \big( X_{t,0,p,w} - X_{t,1,p,w} \big)
\right|.
\]
In the implementation with \texttt{Z3}, the optimization is performed by 
\emph{iterative (binary) search} on a pseudo-Boolean bound \(z\). 
At each step we introduce a constraint of the form 
\(\sum_t \lvert \cdot \rvert \leq z\), encoded using cardinality 
constraints, and solve for feasibility. If satisfiable, the bound 
is tightened; otherwise the process stops at the last feasible value.

\subsubsection{Model - 2 }

As in Model--1, the optimization criterion is to balance the number of
home and away games for each team. Formally:

\[
\min \sum_{t=1}^T \left| \sum_{w=1}^W HOME_{t,w}
      - \Big(W - \sum_{w=1}^W HOME_{t,w}\Big) \right|.
\]


\subsection{Constraints}

\subsubsection{Model - 1 }

\paragraph{Main constraints.}

\begin{itemize}
\item[(C1)] \textbf{Every pair of teams plays at most once.}  
For each distinct pair of teams $t_1,t_2 \in \{1,\dots,T\}$:
\[
\sum_{p=1}^{P}\sum_{w=1}^{W}
\Big( \bigvee_{h\in\{0,1\}} X_{t_1,h,p,w} \;\;\land\;\;
       \bigvee_{h\in\{0,1\}} X_{t_2,h,p,w} \Big)
\;\;\leq 1.
\]

\item[(C2)] \textbf{Each team plays exactly once per week.}  
For every team $t$ and week $w$:
\[
\sum_{h\in\{0,1\}}\sum_{p=1}^{P} X_{t,h,p,w} \;=\; 1.
\]

\item[(C3)] \textbf{Each team appears at most twice in the same period over the tournament.}  
For every team $t$ and period $p$:
\[
\sum_{h\in\{0,1\}}\sum_{w=1}^{W} X_{t,h,p,w} \;\leq\; 2.
\]
\end{itemize}

\paragraph{Implied constraints.}

\begin{itemize}
\item[(C4)] \textbf{Each game slot has exactly one home and one away team.}  
For every period $p$ and week $w$:
\[
\sum_{t=1}^{T} X_{t,1,p,w} = 1
\quad\text{and}\quad
\sum_{t=1}^{T} X_{t,0,p,w} = 1.
\]
\end{itemize}

\paragraph{Simmetry breaking.}

\begin{itemize}
\item[(C5)] {Fixing the first line of the schedule (symmetry-breaking).}  
To reduce symmetry, the matches for the first week / period are fixed:
\[
\bigwedge_{t=1}^{T-1} \big( X_{t,0,1,t} \;\lor\; X_{t,1,1,t} \big)
\quad\land\quad
\big( X_{T,0,1,1} \;\lor\; X_{T,1,1,1} \big).
\]
\end{itemize}

\subsubsection{Model - 2 }

\paragraph{Main constraints.}

\begin{itemize}
\item[(C1)] \textbf{Each team plays with every other team only once;}
\[
\forall\, t_1<t_2\qquad
\sum_{w=1}^{W} M_{t_1,t_2,w} \;=\; 1.
\]

\item[(C2)] \textbf{Each team plays exactly once per week}
\[
\forall\, t,\,w\qquad
\sum_{p=1}^{P} P_{t,p,w} \;=\; 1.
\]

\item[(C3)] \textbf{Each team plays at most twice in the same period}
\[
\forall\, t,\,p\qquad
\sum_{w=1}^{W} P_{t,p,w} \;\le\; 2.
\]

\item[(C4)] \textbf{Each slot \((p,w)\) hosts exactly two teams.}
\[
\forall\, p,\,w\qquad
\sum_{t=1}^{T} P_{t,p,w} \;=\; 2.
\]
\end{itemize}

\paragraph{Implied constraints.}

\begin{itemize}
\item[(C5)] \textbf{Home/away consistency when two teams meet in week \(w\).}
\[
\forall\, w,\, t_1<t_2\qquad
M_{t_1,t_2,w} \;\Rightarrow\; \big(HOME_{t_1,w} \oplus HOME_{t_2,w}\big).
\]

\item[(C6)] \textbf{Link between pair variables and period assignments.}
\[
\forall\, w,\, t_1<t_2\qquad
M_{t_1,t_2,w} \;\Rightarrow\; \bigvee_{p=1}^{P}\big(P_{t_1,p,w}\land P_{t_2,p,w}\big),
\]
\[
\forall\, w,\,p,\, t_1<t_2\qquad
\big(P_{t_1,p,w}\land P_{t_2,p,w}\big) \;\Rightarrow\; M_{t_1,t_2,w}.
\]
(Equivalently: \(M_{t_1,t_2,w}\) iff the two teams share some period \(p\) in week \(w\).)
\end{itemize}

\paragraph{Simmetry breaking.}

\begin{itemize}
\item[(C7)] \textbf{Precomputed round-robin pruning.}
Let \(\mathcal{R}_w\subseteq\{\{t_1,t_2\}\mid t_1<t_2\}\) be the fixed set of pairs for week \(w\) produced by the round-robin generator. Then:
\[
\forall\, w,\, t_1<t_2\qquad
M_{t_1,t_2,w} =
\begin{cases}
1, & \text{if }\{t_1,t_2\}\in \mathcal{R}_w,\\[4pt]
0, & \text{otherwise.}
\end{cases}
\]
\end{itemize}


% === Validation ===

\subsection{Validation}

\paragraph{Experimental Setup} \mbox{}\\
\\
All experiments were conducted using the \texttt{Z3} solver for SAT and
optimization. The implementation is provided in Python, and the solver is
invoked through the \textbf{Z3 API}. 
\\
The experiments were run on two different operating systems, namely
\emph{Windows} and \emph{Linux}, to ensure portability of the implementation.
The hardware platform was a laptop equipped with a \textit{12th Gen
Intel(R) Core(TM) i7-1280P} processor and an \textit{NVIDIA RTX-3060 GPU}. No GPU
acceleration was employed for the SAT solving itself, which ran entirely on
the CPU.  \\
\\
In order to reproduce the experiments, it is sufficient to follow the
instructions provided in the accompanying \texttt{README.md} file, which
details the installation steps and execution commands. The solver was run
without a fixed time limit, but execution times were recorded as reported in
the results section.
\\
For reproducibility, a fixed random seed (\texttt{SEED\_FOR\_REPRODUTION})
can be set in the configuration. By default this seed is set to~0, meaning
that Z3’s internal randomization is left free, but setting it to a positive
integer ensures deterministic and repeatable runs across different executions
and platforms.



\paragraph{Experimental results} \mbox{}\\

The \textbf{following tables reports} the results of the SAT experiments. 
Each row corresponds to a different value of $N$. 
the value of the objective value obtained using different approach. If the instance is solved to optimality is in bold. In addition if the instance is proved to be
unsatisfiable, it is indicate as \textit{UNSAT} and if no answer is obtained within the
time limit are indicate it with \textit{N/A}.
Each modeling approach have is own table (Tab.~\ref{tab:results_sat_m1} and Tab.~\ref{tab:results_sat_m2}).  

The \textbf{precomputation time} required to generate the round-robin pairs is not reported in the tables, as it is negligible: it remains below one second even for 
$N\approx50$, and therefore has no practical impact on the overall computational performance.

% MODEL 1 - TABLE
\begin{table}[h]
\centering
\begin{tabular}{c|c|c|c|c}
\hline
$N$ & Bitwise & Heule & Pairwise & Sequential \\
\hline
2   & \textbf{2}  & \textbf{2}  & \textbf{2} & \textbf{2}  \\
4   & UNSAT  & UNSAT  & UNSAT & UNSAT  \\
6   & \textbf{6}  & \textbf{6}  & \textbf{6} & \textbf{6}  \\
8   & 18        & 16     & 20   &  32 \\
10  & 28        & 26     & 26   &  24 \\
12  & 26        & 40     & 34  &  46 \\
14  & N/A       & N/A    & N/A  &  N/A     \\
\hline
\end{tabular}
\caption{Experimental results of Model 1}
\label{tab:results_sat_m1}
\end{table}

% MODEL 2 - TABLE
\begin{table}[h]
\centering
\begin{tabular}{c|c|c}
\hline
$N$ & Standard & Pre-computing  \\
\hline
2   & \textbf{2}  & \textbf{2}   \\
4   & UNSAT  & UNSAT   \\
6   & \textbf{6}  & \textbf{6}   \\
8   & \textbf{8}           & \textbf{8}    \\
10  & \textbf{10}           & \textbf{10}           \\
12  & \textbf{12}          & \textbf{12}             \\
14  & \textbf{14}          & \textbf{14}                    \\
16  & 46       & \textbf{16}             \\
18  & N/A       & 162             \\
20  & N/A       & N/A             \\
\hline
\end{tabular}
\caption{Experimental results of Model 2}
\label{tab:results_sat_m2}
\end{table}






% ---------------- MIP ----------------
\clearpage
\section{MIP Model}
This section is mandatory.

\subsection{Decision variables}
Before defining the variables, we compute the list $L$ of the possible match-ups, without caring about the order of the $(i,j)$ tuples (we impose $i<j$).
If $n$ is the number of teams, we have $|L|=\binom{n}{2} = \frac{n!}{2!(n-2)!}$, i.e. $\binom{n}{2}$ games to be played.


Our decision variables are then two 3-dimensional tensors of boolean values $Y_{w,p,(i,j)}$ and $H_{w,p,(i,j)}$, where
\begin{itemize}
    \item $Y_{w,p,(i,j)} = 1 \iff$ teams $i$ and $j$ are playing one against the other in week $w$ in period $p$;
    \item $H_{w,p,(i,j)} = 1 \iff$ team $i$ (the team with lowest index since $\forall (i,j) \in L$, $i<j$) is playing home in week $w$ in period $p$.
\end{itemize}

Clearly these variables have to be linked one with the other, and that's why we'll introduce some variable-linking constraint to our model.


\subsection{Objective function}
The objective function is essentially the same as in the former cases, but we have to formulate it in a slightly different way because in linear programming the objective function has to be linear and therefore we cannot use absolute values and $\max/\min$ functions.

We had to find another way to compute
\[
\sum_{t=1}^{T} \Big| \; 
\#\text{home\_games}(t) - \#\text{away\_games}(t) \; \Big|.
\]
For the seek of brevity we will write $h_t$ and $a_t$ instead of $\#\text{home\_games}(t)$ and $\#\text{away\_games}(t)$ respectively.

Let's rewrite the expression of the objective function in a more efficient way: since 
\[
h_t + a_t = W = n-1,
\]
we have
\[
a_t = W - h_t\;\; \text{and}\; \;h_t = W - a_t
\]
and therefore
\begin{align*}
|h_t - a_t| &= |h_t - (W-h_t)|\\
            &= |2 h_t - W|,
\end{align*}
but equivalently
\[
|2 h_t - W| = |h_t - a_t| = |a_t - h_t| = |2a_t - W|.
\]
Distinguishing two different cases:
\begin{align*}
\text{if}\; h_t>a_t\; &\implies |h_t-a_t| = h_t - a_t = 2h_t -W\\
\text{if}\; a_t>h_t\; &\implies |h_t-a_t| = a_t - h_t = 2a_t -W,
\end{align*}
we can then state that
\[
|h_t-a_t| = 2\max(h_t,a_t) - W.
\]

Once we define a function to sum up the home games and assigning the value to an integer variable $h_t$ for each team $t$, the away games are computed as $a_t = W - h_t$, where $W=n-1$ is the total number of games played by each team.

We then compute the maximum between $a_t$ and $h_t$ defining a new integer variable $max(H/A)_t$ and imposing it to be greater or equal than both $a_t$ and $h_t$, in this way we avoid using a max function, using instead just linear inequalities. Since we look for a minimal value of the objective function we don't need to set an upper bound to the $max(H/A)_t$ values.

Now we can compute the total balance as
\[
\sum^T_{t=1}\;(\;2\,max(H/A)_t -W\;)
\]
that is a valid objective function being linear in the $max(H/A)_t$ variables.




\subsection{Constraints}

\subsubsection{Variable linking constraint}
As already mentioned, we have to link the variables and this has to be done by adding linear inequalities to our linear program.

The only constraint we have to add is the one that ensures that $H_{w,p,(i,j)}\neq1$ if teams $i$ and $j$ do not play against in week $w$ in period $p$, i.e.
\[
Y_{w,p,(i,j)} = 0\implies H_{w,p,(i,j)}\neq1.
\]
This constraint can be translated in a linear inequality by imposing
\[
H_{w,p,(i,j)} \leq Y_{w,p,(i,j)}.
\]

\subsubsection{Main constraints}
\begin{itemize}
\item[(C1)] \textbf{Each team plays with every other team only once;}
\[
\forall\, (i,j) \in L \qquad
\sum_{w,p} Y_{w,p,(i,j)} \;=\; 1.
\]

\item[(C2)] \textbf{Each team plays exactly once per week}
\[
\forall\, t,\,w\qquad
\sum_{p=1}^{P}( Y_{w,p,(t,j)} + Y_{w,p, (i,t)}) \;=\; 1.
\]
In this case and in the next, the boolean variables that are taken in account are those relative to $t$, i.e. those where $i=t$ or $j=t$.
\item[(C3)] \textbf{Each team plays at most twice in the same period}
\[
\forall\, t,\,p\qquad
\sum_{w=1}^{W}( Y_{w,p,(t,j)} + Y_{w,p, (i,t)}) \;\le\; 2.
\]

\item[(C4)] \textbf{Each slot \((p,w)\) hosts exactly one game.}
\[
\forall\, p,\,w:\qquad
\sum_{t=1}^{T} Y_{w,p,(i,j)} \;=\; 1.
\]
With this model we don't need to explicitly ask for exactly two teams in each slot because we already computed the match-ups as couples.
\end{itemize}

\subsubsection{Symmetry breaking constraints}
\begin{itemize}
    \item[(C4)] We fix each match in the first week by imposing:
    \begin{align*}
        \forall p =1,\dots,P\qquad   &Y_{1,p,(2p-1,\,2p)}=1\\
        &H_{1,p,(2p-1,\,2p)}=1
    \end{align*}
    
    
    \item[(C4)] We can further restrict the problem by imposing that $team1$ plays the first P matches at home; this can be possible since we don't care about the H/A alternation during the weeks and it helps to obtain the optimal value of the objective function because it ensures at least $P$ home matches for $team1$. We formulate it as follows:
    \[
    \forall p = 1,\dots,P\qquad\sum_{j=2}^TH_{p,p, (1,\,j)}=1.
    \]
    We're summing over the remaining teams $j$ cause we don't want to restrict by choosing the away team.
\end{itemize}

\subsection{Validation}
Run on at least one MIP solver; solver-independent modeling (e.g., \texttt{AMPL}) is a plus.
Report as in CP.

% --------------- Conclusions ---------------
\section{Conclusions}
Summarize findings, modeling trade-offs, and comparative performance insights.

% --------------- Authorship ---------------
\section*{Authenticity and Author Contribution Statement}
We declare that the work reported here is our own and properly cites all external ideas and sources.
Parts of this project (text/code/experiments) were assisted by AI tools where indicated; we disclose the tools used and the exact sections where AI assistance was applied.
\\[0.5em]
\textbf{Author contributions.} Briefly outline the role of each author (modeling, implementation, experiments, analysis, writing).

% --------------- References ---------------
\begin{thebibliography}{9}

\bibitem{minizinc}
MiniZinc: The Modeling Language,
\url{https://www.minizinc.org/}.


\end{thebibliography}

\end{document}

